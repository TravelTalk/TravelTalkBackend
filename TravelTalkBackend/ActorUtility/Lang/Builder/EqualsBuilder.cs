namespace ActorUtilityTravelTalk.ActorUtility.Lang.Builder {
    using System;
    using System.Linq;
    using Extensions;

    /// <summary>
    ///     Class providing means to implement the <see cref="object.Equals(object)"/> method in a concise and consistent way.
    ///     This class is consistend with the <see cref="HashCodeBuilder"/> class, so that equal objects are guaranteed to return
    ///     the same hash code value.
    /// </summary>
    /// <example>
    ///     The following example shows how to use this class in the <see cref="object.Equals(object)"/> method of a class.
    ///     <code>
    ///  public class Person {
    /// 		public string Name { get; set; }
    /// 	
    /// 		public bool Equals(object object) {
    /// 			if (!(obj is Person)) {
    /// 				return false;
    /// 			}
    /// 
    /// 			Person person = (Person) obj;
    /// 			return new EqualsBuilder()
    /// 				.Append(Name, person.Name).IsEqual;	
    /// 		}
    ///  }
    ///  </code>
    /// </example>
    public sealed class EqualsBuilder {

        /// <summary>
        ///     Gets whether or not all tested objects are equal.
        /// </summary>
        /// <returns><c>true</c> if all tested objects are equal, <c>false</c> otherwise.</returns>
        public bool IsEqual { get; private set; } = true;

        /// <summary>
        ///     Tests if two <see cref="object"/>s are equal, using their <see cref="object.Equals(object)"/> method.
        /// </summary>
        /// <param name="lhs">The left hand side <see cref="object"/>.</param>
        /// <param name="rhs">The right hand side <see cref="object"/>.</param>
        /// <returns>This <see cref="EqualsBuilder"/> instance, which may be used for chaining.</returns>
        public EqualsBuilder Append(object lhs, object rhs) {
            if (!IsEqual || lhs == rhs) {
                return this;
            }

            if (lhs == null || rhs == null) {
                IsEqual = false;
                return this;
            }

            if (!lhs.GetType().IsArray) {
                // The simple case, not an array, just test the element
                IsEqual = lhs.Equals(rhs);
            } else if (!rhs.GetType().IsArray) {
                // Here lhs is an array and rhs is not an array, hence they cannot be equal
                IsEqual = false;
            } else {
                // Both lhs and rhs are arrays
                object[] lhsArray = (object[]) lhs;
                object[] rhsArray = (object[]) rhs;
                IsEqual = lhsArray.SequenceEqual(rhsArray);
            }

            return this;
        }

        /// <summary>
        ///     Tests if two <see cref="double"/> values are equal, optionally using a given <paramref name="precisionDigits"/>.
        ///     <para>
        ///         This method is compatible with the hash code generated by <see cref="HashCodeBuilder"/> when being invoked with
        ///         the same value for <paramref name="precisionDigits"/>.
        ///     </para>
        /// </summary>
        /// <param name="lhs">The left hand side <see cref="double"/> value.</param>
        /// <param name="rhs">The right hand side <see cref="double"/> value.</param>
        /// <param name="precisionDigits">
        ///     The number of decimal digits that must be zero in the absolute difference |<paramref name="lhs"/> - <paramref name="rhs"/>| in
        ///     order to be considered as equal. If <paramref name="precisionDigits"/> is zero, the two <see cref="double"/> values must match
        ///     exactly to be treated as equal. Must be non-negative. Defaults to 0.
        /// </param>
        /// <returns>This <see cref="EqualsBuilder"/> instance, which may be used for chaining.</returns>
        /// <exception cref="ArgumentOutOfRangeException">If the <paramref name="precisionDigits"/> argument is negative.</exception>
        public EqualsBuilder Append(double lhs, double rhs, int precisionDigits = 0) {
            if (!IsEqual) {
                return this;
            }

            IsEqual = lhs.EqualsNDigitsPrecision(rhs, precisionDigits);
            return this;
        }

        /// <summary>
        ///     Tests if two <see cref="decimal"/> values are equal, optionally using a given <paramref name="precisionDigits"/>.
        ///     <para>
        ///         This method is compatible with the hash code generated by <see cref="HashCodeBuilder"/> when being invoked with
        ///         the same value for <paramref name="precisionDigits"/>.
        ///     </para>
        /// </summary>
        /// <param name="lhs">The left hand side <see cref="decimal"/> value.</param>
        /// <param name="rhs">The right hand side <see cref="decimal"/> value.</param>
        /// <param name="precisionDigits">
        ///     The number of decimal digits that must be zero in the absolute difference |<paramref
        ///                                                                                    name="lhs"/> - <paramref name="rhs"/>| in order to be considered as equal.
        ///     If <paramref name="precisionDigits"/>
        ///     is zero, the two <see cref="decimal"/> values must match exactly to be treated as equal. Must be non-negative.
        ///     Defaults to 0.
        /// </param>
        /// <returns>This <see cref="EqualsBuilder"/> instance, which may be used for chaining.</returns>
        /// <exception cref="ArgumentOutOfRangeException">If the <paramref name="precisionDigits"/> argument is negative.</exception>
        public EqualsBuilder Append(decimal lhs, decimal rhs, int precisionDigits = 0) {
            if (!IsEqual) {
                return this;
            }

            IsEqual = lhs.EqualsNDigitsPrecision(rhs, precisionDigits);
            return this;
        }

        /// <summary>
        ///     Tests if two <see cref="float"/> values are equal, optionally using a given <paramref name="precisionDigits"/>.
        ///     <para>
        ///         This method is compatible with the hash code generated by <see cref="HashCodeBuilder"/> when being invoked with
        ///         the same value for <paramref name="precisionDigits"/>.
        ///     </para>
        /// </summary>
        /// <param name="lhs">The left hand side <see cref="float"/> value.</param>
        /// <param name="rhs">The right hand side <see cref="float"/> value.</param>
        /// <param name="precisionDigits">
        ///     The number of decimal digits that must be zero in the absolute difference |<paramref
        ///                                                                                    name="lhs"/> - <paramref name="rhs"/>| in order to be considered as equal.
        ///     If <paramref name="precisionDigits"/>
        ///     is zero, the two <see cref="float"/> values must match exactly to be treated as equal. Must be non-negative.
        ///     Defaults to 0.
        /// </param>
        /// <returns>This <see cref="EqualsBuilder"/> instance, which may be used for chaining.</returns>
        /// <exception cref="ArgumentOutOfRangeException">If the <paramref name="precisionDigits"/> argument is negative.</exception>
        public EqualsBuilder Append(float lhs, float rhs, int precisionDigits = 0) {
            return !IsEqual ? this : Append((double) lhs, rhs, precisionDigits);
        }

        /// <summary>
        ///     Tests if two <see cref="long"/> values are equal.
        /// </summary>
        /// <param name="lhs">The left hand side <see cref="long"/> value.</param>
        /// <param name="rhs">The right hand side <see cref="long"/> value.</param>
        /// <returns>This <see cref="EqualsBuilder"/> instance, which may be used for chaining.</returns>
        public EqualsBuilder Append(long lhs, long rhs) {
            if (!IsEqual) {
                return this;
            }

            IsEqual = lhs == rhs;
            return this;
        }

        /// <summary>
        ///     Tests if two <see cref="ulong"/> values are equal.
        /// </summary>
        /// <param name="lhs">The left hand side <see cref="ulong"/> value.</param>
        /// <param name="rhs">The right hand side <see cref="ulong"/> value.</param>
        /// <returns>This <see cref="EqualsBuilder"/> instance, which may be used for chaining.</returns>
        public EqualsBuilder Append(ulong lhs, ulong rhs) {
            if (!IsEqual) {
                return this;
            }

            IsEqual = lhs == rhs;
            return this;
        }

        /// <summary>
        ///     Tests if two <see cref="int"/> values are equal.
        /// </summary>
        /// <param name="lhs">The left hand side <see cref="int"/> value.</param>
        /// <param name="rhs">The right hand side <see cref="int"/> value.</param>
        /// <returns>This <see cref="EqualsBuilder"/> instance, which may be used for chaining.</returns>
        public EqualsBuilder Append(int lhs, int rhs) {
            return !IsEqual ? this : Append((long) lhs, rhs);
        }

        /// <summary>
        ///     Tests if two <see cref="uint"/> values are equal.
        /// </summary>
        /// <param name="lhs">The left hand side <see cref="uint"/> value.</param>
        /// <param name="rhs">The right hand side <see cref="uint"/> value.</param>
        /// <returns>This <see cref="EqualsBuilder"/> instance, which may be used for chaining.</returns>
        public EqualsBuilder Append(uint lhs, uint rhs) {
            return !IsEqual ? this : Append((ulong) lhs, rhs);
        }

        /// <summary>
        ///     Tests if two <see cref="short"/> values are equal.
        /// </summary>
        /// <param name="lhs">The left hand side <see cref="short"/> value.</param>
        /// <param name="rhs">The right hand side <see cref="short"/> value.</param>
        /// <returns>This <see cref="EqualsBuilder"/> instance, which may be used for chaining.</returns>
        public EqualsBuilder Append(short lhs, short rhs) {
            return !IsEqual ? this : Append((int) lhs, rhs);
        }

        /// <summary>
        ///     Tests if two <see cref="ushort"/> values are equal.
        /// </summary>
        /// <param name="lhs">The left hand side <see cref="ushort"/> value.</param>
        /// <param name="rhs">The right hand side <see cref="ushort"/> value.</param>
        /// <returns>This <see cref="EqualsBuilder"/> instance, which may be used for chaining.</returns>
        public EqualsBuilder Append(ushort lhs, ushort rhs) {
            return !IsEqual ? this : Append((uint) lhs, rhs);
        }

        /// <summary>
        ///     Tests if two <see cref="char"/> values are equal.
        /// </summary>
        /// <param name="lhs">The left hand side <see cref="char"/> value.</param>
        /// <param name="rhs">The right hand side <see cref="char"/> value.</param>
        /// <returns>This <see cref="EqualsBuilder"/> instance, which may be used for chaining.</returns>
        public EqualsBuilder Append(char lhs, char rhs) {
            return !IsEqual ? this : Append((short) lhs, rhs);
        }

        /// <summary>
        ///     Tests if two <see cref="byte"/> values are equal.
        /// </summary>
        /// <param name="lhs">The left hand side <see cref="byte"/> value.</param>
        /// <param name="rhs">The right hand side <see cref="byte"/> value.</param>
        /// <returns>This <see cref="EqualsBuilder"/> instance, which may be used for chaining.</returns>
        public EqualsBuilder Append(byte lhs, byte rhs) {
            return !IsEqual ? this : Append((short) lhs, rhs);
        }

        /// <summary>
        ///     Tests if two <see cref="bool"/> values are equal.
        /// </summary>
        /// <param name="lhs">The left hand side <see cref="bool"/> value.</param>
        /// <param name="rhs">The right hand side <see cref="bool"/> value.</param>
        /// <returns>This <see cref="EqualsBuilder"/> instance, which may be used for chaining.</returns>
        public EqualsBuilder Append(bool lhs, bool rhs) {
            if (!IsEqual) {
                return this;
            }

            IsEqual = lhs == rhs;
            return this;
        }

        /// <summary>
        ///     Tests if two <see cref="string"/> values are equal, using the specified string comparator.
        /// </summary>
        /// <param name="lhs">The left hand side <see cref="string"/> value.</param>
        /// <param name="rhs">The right hand side <see cref="string"/> value.</param>
        /// <param name="stringComparison">The string comparison rule used for the equals test.</param>
        /// <returns>This <see cref="EqualsBuilder"/> instance, which may be used for chaining.</returns>
        public EqualsBuilder Append(string lhs, string rhs, StringComparison stringComparison) {
            if (!IsEqual) {
                return this;
            }

            IsEqual = string.Equals(lhs, rhs, stringComparison);
            return this;
        }

        /// <summary>
        ///     Tests if two <see cref="string"/> values are functional equal (i.e. <c>null</c> and empty strings are considered equal).
        /// </summary>
        /// <param name="lhs">The left hand side <see cref="string"/> value.</param>
        /// <param name="rhs">The right hand side <see cref="string"/> value.</param>
        /// <returns>This <see cref="EqualsBuilder"/> instance, which may be used for chaining.</returns>
        public EqualsBuilder AppendNullAsEmpty(string lhs, string rhs) {
            return !IsEqual ? this : Append(lhs ?? string.Empty, rhs ?? string.Empty);
        }

        /// <summary>
        ///     Adds the result of <c>base.Equals(object)</c> to this builder.
        /// </summary>
        /// <param name="baseEquals">The result when calling <c>base.Equals(object)</c>.</param>
        /// <returns>This <see cref="EqualsBuilder"/> instance, which may be used for chaining.</returns>
        public EqualsBuilder AppendBase(bool baseEquals) {
            if (!IsEqual) {
                return this;
            }

            IsEqual &= baseEquals;
            return this;
        }

        public void Reset() {
            IsEqual = true;
        }
    }
}
